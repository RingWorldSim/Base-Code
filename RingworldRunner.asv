function res = RingworldRunner()
tic
%Function simulates Ringworld as a series of point masses distributed
%around a central point.

k = 0; %spring constant between the segments of Ringworld
vinitial = 1; % Initial velocity of each piece of the ring
position_Sun = [0;0];
mass_Sun = 1.989*10^30;


number_of_masses = 4;
mass_ring = 10; %Total mass of the ring
ring_radius = 10;
mass_of_piece = mass_ring/number_of_masses;
mass_positions = create_positions(number_of_masses, ring_radius); %positions of each mass
mass_velocities = create_velocities(number_of_masses, vinitial); %velocity vector for each

year = 365*24*60*60;
time = year*10;
%%
initial_conditions = unsortData(mass_positions, mass_velocities);
[t,Y] = ode45(@differentials, [0, time], initial_conditions);

final_positions = Y(:, 1:length(Y(1,:))/2); %Gets the first half of the Y matrix
animate(t, final_positions)


%%
    function res = differentials(t, Y)
        [positions, velocities] = sortData(Y);
        
        dp = velocities;
        dv = find_acceleration(positions, mass_of_piece, mass_Sun, position_Sun, k);
        
        res = unsortData(dp, dv)';
    end 

%%
    function animate(t, final_positions)
        for i = 1:length(t)
           position_data = final_positions(i, :);
           counter = 1;
           while counter < length(position_data);
               plot(position_data(counter), position_data(counter+1))
               counter = counter + 2;
           end
           drawnow;
        end
    end
toc
end